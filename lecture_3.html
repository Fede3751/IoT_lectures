<html>
	<head>
		<link rel="stylesheet" href="style.css">
	</head>
	<body>
		<div id="main">
			<p class="title"> IoT Lab Lecture 3 - 23/03/2023 </p>

			<div class="divider"></div>

           <p>
                In this lecture we will see the next big component of the ROS Graph: services.<br>
                We will see how we can write a script to create a service server and a service client to exchange data in a more structured
                way than topics.<br>
                Additionally, we are dedicating a small part to see how you can implement your custom interfaces and write parameters for
                your ROS node.<br><br>

				Some excercises are given to test your coding skills with the new knowledge acquired in this lecture.<br><br>

                Let's get started!
           </p> 


            <p class="section">Writing services</p>
			<p>
				We have seen how to write and use topics by writing a script. This leaves us only with services and actions to tackle.<br><br>

				Let's now try to write a simple service and client in Python.<br>
				We will follow an example just like we did before. But this time from here on this page.

				<p class="code">
					ros2 pkg create --build-type ament_python py_srvcli --dependencies rclpy example_interfaces
				</p>

				This time, we are specifying a dependency that our application needs in order to run the service structure.<br>
				This command is not required assuming you have everything already installed, but it is a good practice to specify what
				your package needs in order to run.<br><br>

				If for some reasons you realize that your package has further dependencies after you created it, you can specify them manually
				by writing in the <span class="snippet">package.xml</span> file, it should be kinda intuitive how to edit it.<br><br>

				Now create a new file in <span class="snippet">/src/py_srvcli/py_srvcli</span> called
				<span class="snippet">service_member_function.py</span>, this will be the file were we will write our
				service server.<br><br>

				The code of the node is the following. It is highly reccomended to write it line by line instead of copying it, so you can get a good understanding
				of what we're doing.

                    <pre>
from example_interfaces.srv import AddTwoInts

import rclpy
from rclpy.node import Node


class MinimalService(Node):

    def __init__(self):
        super().__init__('minimal_service')
        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)

    def add_two_ints_callback(self, request, response):
        response.sum = request.a + request.b
        self.get_logger().info('Incoming request\na: %d b: %d' % (request.a, request.b))

        return response


def main():
    rclpy.init()

    minimal_service = MinimalService()

    rclpy.spin(minimal_service)

    rclpy.shutdown()


if __name__ == '__main__':
    main()
                    </pre>

				Let's comment the new things we're seeing in this script.<br><br>

				The imported libraries are the same as before for what regards ROS.<br>
				This time though, we are also importing an example interface called <span class="snippet">AddTwoInts</span> from the
				<span class="snippet">example_interfaces</span> package.<br><br>

				This time, we create a service server using the <span cass="snippet">Node</span> method <span class="snippet">create_service()</span>.<br>
				Here, we specify, once again, the message type for the service, the service name, and the callback function.<br>
				Things are not so different from writing for a topic.<br><br>

				The callback <span class="snippet">add_two_ints_callback()</span> takes in input, by default, the request and the response.<br><br>

				Things may get confusing here, but everything may make more sense if we are able to understand how an <span class="snippet">AddTwoInts</span>
				message is structured. Do you remember how to do it?

				<p class="code">
					ros2 interface show example_interfaces/srv/AddTwoInts
				</p>

				<img class="centered" src="imgs/lecture_3/addtwoints_interface.png">

				This tells us the fields of a request, and those of the response!<br><br>

				Now we can go back to our, code, and it should be clear what the following snippet does:

				<pre>
def add_two_ints_callback(self, request, response):
    response.sum = request.a + request.b
    self.get_logger().info('Incoming request\na: %d b: %d' % (request.a, request.b))

    return response
				</pre>

				The rest of the code is exactly like what we have seen before!<br><br>


				We now need to add an entry point for this service, just like we did before for the two talker and listener nodes.<br>
				You should be able to do it by now.<br><br>

				Let's now write the code for our client of the service.<br>
				Create a file named <span class="snippet">client_member_function.py</span> in the <span class="snippet">src/py_srvcli/py_srvcli</span> folder, and write in it the following code:

				<pre>
import sys

from example_interfaces.srv import AddTwoInts
import rclpy
from rclpy.node import Node


class MinimalClientAsync(Node):

    def __init__(self):
        super().__init__('minimal_client_async')
        self.cli = self.create_client(AddTwoInts, 'add_two_ints')
        while not self.cli.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('service not available, waiting again...')
        self.req = AddTwoInts.Request()

    def send_request(self, a, b):
        self.req.a = a
        self.req.b = b
        self.future = self.cli.call_async(self.req)
        rclpy.spin_until_future_complete(self, self.future)
        return self.future.result()


def main():
    rclpy.init()

    minimal_client = MinimalClientAsync()
    response = minimal_client.send_request(int(sys.argv[1]), int(sys.argv[2]))
    minimal_client.get_logger().info(
        'Result of add_two_ints: for %d + %d = %d' %
        (int(sys.argv[1]), int(sys.argv[2]), response.sum))

    minimal_client.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
				</pre>

				<br>Let's comment the most interesting parts of this code.

				<pre>
while not self.cli.wait_for_service(timeout_sec=1.0):
    self.get_logger().info('service not available, waiting again...')
self.req = AddTwoInts.Request()
				</pre>

				With the first two lines, we are telling our node to wait for the service to be available before continuing with the execution.<br>
				After that, we instantiate our request message by using the constructor <span class="snippet">Request()</span> of our <span class="snippet">AddTwoInts</span> interface.<br><br>

				The other interesting snippet is how the service is called:

				<pre>
def send_request(self, a, b):
    self.req.a = a
    self.req.b = b
    self.future = self.cli.call_async(self.req)
    rclpy.spin_until_future_complete(self, self.future)
    return self.future.result()
				</pre>

				Here, we are configuring our request and then using it in the function <span class="snippet">call_async()</span>.<br>
				This allows the node to call a service without blocking the rest of the execution of the code.
				<strong>Never</strong> use the function <span class="snippet">call()</span>, unless you are ready to mess with Python Threading.<br><br>
				
				We then use <span class="snippet">spin_until_future_complete()</span> to wait for the service to answer and give us a result.
				Which we then obtain using the <span class="snippet">future.result()</span> function.<br><br>

				The rest of the code should be kinda self explanatory and not too much different from what we have already seen.<br>
				Feel free to ask questions if something is still unclear up to this point.<br><br>

				
				<p class="subsection">Linking again and running</p>

				Now that we also wrote our client, we are ready to add the entry point also for it. After that, we are finally ready to test our example.<br>
				Go back to the main folder and build the package again (remember that you may need to check the dependencies with <span class="snippet">rosdep</span> before being able to build).<br><br>

				Now, after sourcing your package, you should be able to run your service with the following commands.<br>
				First, start the service with:

				<p class="code">
					ros2 run py_srvcli service
				</p>

				And then make a request to it with the client node:

				<p class="code">
					ros2 run py_srvcli client 2 3
				</p>

				This should output something like this:

				<img class="centered" src="imgs/lecture_3/service_client.png">

			</p>


			<p class="section">Excercise 3 - <span class="rainbow-text">Rainbow</span> Turtle!</p>

			<p>
				We now know how to write services in ROS.<br>

				Let's go back to the excercise we did before and complicate things a little bit!<br><br>

				You are here asked to change the script in Excercise 2 as follows:<br>
				when the turtle reaches a corner, the color of the line the turtle leaves behind should change!<br><br>

				There is one particular service responsable for the color of the line, try to find it out by tinkering
				with all the commands we have seen so far (looking online for more documentation, if you are having problems, is totally fair)!<br><br>

				Some tips may be needed here, as using topics and services together can create lots of problems without knowing how ROS works under the hood.
				The most important thing you need to know: you should <strong>NEVER call a spin action for a node that is already spinning</strong>, that can create problems in the 
				scheduler of ROS.<br><br>
				If you want to see the result of a service from a node, but that node is already spinning, you may use the function
				<span class="snippet">future.add_done_callback()</span>, which allows you to specify a function which gets executed
				when the service has answered your request. You shouldn't neeed the function in this excercise, but is good to know its existence for the <i>future</i>.<br><br>

				Good luck!<br><br>

				Your solution should look something like this:

            </p>

            <img class="centered" src="imgs/lecture_3/rainbow_turtle.png">

				
            <input class="spoilerbutton" type="button" value="Show" onclick="this.value=this.value=='Show'?'Hide':'Show';">
            <div class="spoiler">
                <div>
                    <p>
                        So, first of all. The service you want to send data to is <span class="snippet">/turtle1/set_pen</span>.<br><br>
						You should know by now how to get more info on services and interfaces (<span class="snippet">ros2 service type [service_name]</span> for the message type, and
						<span class="snippet">ros2 interface show [interface_name]</span> for the interface).<br><br>

						With that being done, let's edit our <span class="snippet">turtle_publisher.py</span> to accomodate the new request.<br>
						First of all, we want to include the new interface in our code (we are also importing <span class="snippet">randint</span> in order to pick a random color).

						<p class="code">
							from turtlesim.srv import SetPen<br>
							from random import randint
						</p>

						Then, in our class <span class="snippet">__init__()</span> function we are adding few lines to subscribe to the service and instantiate a variable for the request

						<p class="code">
							self.client = self.create_client(SetPen, '/turtle1/set_pen')<br>
							self.req = SetPen.Request()
						</p>

						What we need to add now, is a request to <span class="snippet">/turtle1/set_pen</span> in our <span class="snippet">timer_callback()</span> function, just like we
						did in the service client example from before.

						<p class="code">
							self.req.r = randint(0, 255)<br>
							self.req.g = randint(0, 255)<br>
							self.req.b = randint(0, 255)<br>
							self.req.width = 10<br>
							self.req.off = 0<br><br>
					
							self.future = self.client.call_async(self.req)<br>
							self.publisher.publish(msg)
						</p>


						That's it!<br>
						As it was suggested, this time we should not use the function <span class="snippete">spin_until_future_complete()</span>, mainly for two reasons: first of all
						our node is already spinning, and calling the function will mess with the ROS execution of our program, secondly, we don't care about the result of the service,
						we just care about sending a message to it in order to change the color of the turtle's trail.<br><br>

						Great! Now you can build your package as usual an try to run it!<br><br>

						The full code of the solution is uploaded here: <a href="excercise_solutions/excercise_3/rainbow_client.py">rainbow_client.py</a>
                    </p>
                </div>
            </div>


        

			<p class="section">Creating your own Interfaces</p>

			<p>
				If you paid attention to the code carefully, you may have noticed that the code we wrote is using a message of type
				<span class="snippet">AddTwoInts</span>. In order to be able to comfortably work with ROS, you may be 
				required to be able to implement custom messages to pass to your services and topics. This is what we are going to cover in this part!<br><br>

				We will use the same workspace we used so far to test our new interface, so just go back to your
				<span class="snippet">src</span> folder and type:

				<p class="code">
					ros2 pkg create --build-type ament_cmake tutorial_interfaces
				</p>

				This time, we will have to use, sadly, a CMake package. There is currently no way to generate
				<span class="snippet">.msg</span> and <span class="snippet">.srv</span> files in a pure Python package. <br><br>

				What we will do, in order to not use C++, is to define our interfaces in a separate CMake package,
				and then use them inside another Python package.<br><br>

				Interfaces should be defined in their own directories in the package folder, so, just type:

				<p class="code">
					cd tutorial_interfaces <br><br>
					mkidr msg<br>
					mkdir srv
				</p>

				We can start defining our interfaces by creating files in their own folder.<br><br>
				
				Open the <span class="snippet">msg</span> folder, and create a file named <span class="snippet">Num.msg</span>.<br>
				Just open it, and write the following line:

				<p class="code">
					int64 num
				</p>

				And also another file called <span class="snippet">Sphere.msg</span> with the following content:

				<p class="code">
					geometry_msgs/Point center<br>
					float64 radius
				</p>

				This should give you an idea on how to define custom messages that are composed of other already
				defined messages.<br><br>

				Let's now try to create a srv interface!<br><br>

				Go back, and open the <span class="snippet">srv</span> folder. Inside of it, create a file called
				<span class="snippet">AddThreeInts.srv</span> and write in it the following lines:

				<p class="code">
					int64 a<br>
					int64 b<br>
					int64 c<br>
					---<br>
					int64 sum
				</p>

				Here, we are defining a service message which takes in input three integers (<span class="snippet">a</span>, <span class="snippet">b</span> and <span class="snippet">c</span>)
				and returns a single value <span class="snippet">sum</span>.<br><br><br>


				What we have to do now is just to link this new interfaces so that <span class="snippet">colcon</span>
				is able to find them when we buid our package.<br><br>

				In the folder of our interface package, open the file <span class="snippet">CmakeList.txt</span> and
				add the following lines:

				<pre>
find_package(geometry_msgs REQUIRED)
find_package(rosidl_default_generators REQUIRED)

rosidl_generate_interfaces(${PROJECT_NAME}
    "msg/Num.msg"
    "msg/Sphere.msg"
    "srv/AddThreeInts.srv"
    DEPENDENCIES geometry_msgs # Add packages that above messages depend on, in this case geometry_msgs for Sphere.msg
)
				</pre>

				All that is left now is to specify the dependencies our package relies on.<br>
				In order to do that, we will have to edit the file <span class="snippet">package.xml</span>.<br><br>

				Interfaces rely on <span class="snippet">rosidl_default_generators</span> in order to generate
				language-specific code, so we will have to add it to our execution-stage dependencies using the tag
				<span class="snippet">&#60;exec_depend&#62;</span>.<br>
				This package belongs to the dependency group <span class="snippet">rosidl_interface_packages</span>,
				which can be defined using the tag <span class="snippet">&#60;member_of_group&#62;</span>.<br>
				Additionally, we have to define our dependency to <span class="snippet">geometry_msgs</span>.<br><br>

				Add the following lines to <span class="snippet">package.xml</span>:

				<p class="code">
					&#60;depend&#62;geometry_msgs&#60;/depend&#62;<br><br>

					&#60;build_depend&#62;rosidl_default_generators&#60;/build_depend&#62;<br>
					&#60;exec_depend&#62;rosidl_default_runtime&#60;/exec_depend&#62;<br>
					&#60;member_of_group&#62;rosidl_interface_packages&#60;/member_of_group&#62;
				</p>
				

				This complete everything you need to do in order to implement your interfaces.<br><br>
				
				Go back to the main folder of your workspace, and try to build everything like we always did.<br>
				If you now source you new package, you should be able to see your interfaces with the command:

				<p class="code">
					ros2 interface show [interface_name]
				</p>

				Great! this complete almost everything we need to know about interfaces!<br><br>

				If you wish to build interfaces and write Python code in the same package, you can build your package
				using the <span class="snippet">--build type</span> set to <span class="snippet"> ament_cmake_python</span>.<br>
				There is currently no plan to discuss these type of packages. For the rest of the course we will mainly
				use different packages like	we just did.<br><br>

				If you want to test your new interfaces, you can try to edit your service and client script we wrote before
				to take <span class="snippet">AddThreeInts</span> in input. If you did the exercises before, it shouldn't
				be hard at all. Give it a try!<br><br>

			</p>



			<p class="section">Excercise 4 - Spin Turtle!</p>

			<p>
				Let's have more "fun" with the turtle!<br><br>

				Now that we know how to write custom interfaces and use them, it is time to test them.<br><br>

				You are here asked to create a service which, when requested, makes the turtle spin on itself for some time.<br>
				The service should use a custom interface message, which takes in input the direction of the spin, and returns a message of your 
				choice as soon as the spin has started (you can use a simple <span class="snippet">string</span> message as a response).<br><br>

				The turtle should do something like this, when requested by the service:

				<img class="centered" src="imgs/lecture_3/turtle_spin.gif">

			</p>


				<input class="spoilerbutton" type="button" value="Show" onclick="this.value=this.value=='Show'?'Hide':'Show';">
				<div class="spoiler">
					<div>
						<p>
							This excercise was not discussed in class. Solution will be online in a few days!<br>
							Keep trying! You got it!
						</p>
					</div>
				</div>

		
            <p class="section">Setting Parameters for your Nodes</p>


			<p>
				Sometimes you may have the need to expose some properties of your nodes outside the scope of your code, maybe to allow 
				some customization or flexibility of the package you are developing.<br>
				This exactly what paremeters are for.<br>
				Additionally, parameters can be set at launch time by defining a special ROS launch file. We will see how to do that in the next lecture.<br><br>

				Creating and setting parameters is pretty easy and straightforward, let's see how we can do it.<br><br>

				Let's create a package for an example:

				<p class="code">
					ros2 pkg create --build-type ament_python python_parameters --dependencies rclpy
				</p>

				<br>And let's create in the appropriate directory a new file called <span class="snippet">python_parameters_node.py</span>.<br>

				This will be the code for our node:

				<pre>
import rclpy
import rclpy.node

class MinimalParam(rclpy.node.Node):
	def __init__(self):
		super().__init__('minimal_param_node')

		self.declare_parameter('my_parameter', 'world')
		self.timer = self.create_timer(1, self.timer_callback)

	def timer_callback(self):
		my_param = self.get_parameter('my_parameter').get_parameter_value().string_value
		self.get_logger().info('Hello %s!' % my_param)

		my_new_param = rclpy.parameter.Parameter(
			'my_parameter',
			rclpy.Parameter.Type.STRING,
			'world'
		)

		all_new_parameters = [my_new_param]
		self.set_parameters(all_new_parameters)

def main():
	rclpy.init()
	node = MinimalParam()
	rclpy.spin(node)

if __name__ == '__main__':
	main()
				</pre>

				<br>Let's comment this code for a little bit.<br>
				As we have previously seen before, in the <span class="snippet">__init__()</span> function we are defining the node name, and scheduling a periodic action of the method <span class="snippet">timer_callback()</span>.<br>
				Additionally, we are defining a parameter named "my_parameter" with a value of "world" using the function <span class="snippet">declare_parameter()</span>.<br><br>

				In the <span class="snippet">timer_callback()</span> method, we have two important functions that are used to interact with parameters.<br>
				One of them is <span class="snippet">get_parameter().get_parameter_value()</span> which allows us to read parameter values and use them in the code.<br>
				The second important function is <span class="snippet">set_parameters()</span>, which allows us to set parameters given in input to a desired value.<br><br>

				What this code does is, essentially, in case of an external modification of the value, resetting every second the "my_parameter" parameter to the "world" value.<br><br><br>


				You can test its execution, after linking, compiling and running it, by changing the parameter from console using the command:

				<p class="code">
					ros2 param set /minimal_param_node my_parameter earth
				</p>

				<br>And that's it!
			</p>


			<!-- <p class="section">Defining a Launch File</p>

			<p>
				Starting every node from console every time is a hassle. Isn't it?<br><br>

				ROS programs can be composed of multiple nodes, communicating with each other.<br>
				Luckily for us, ROS allows us to define a launch file that can be used to start multiple nodes at runtime<br><br>

				Launch file allow to configure multiple things in your ROS project, more than we will be able to cover in a short amount of time.<br><br>

				What we will see here, is simply how you can define a launch file to start multiple nodes, and to change parameters.<br><br>

				If you wish to go into more detail on how you can configure them, please refer to the offical documentation <a href="https://docs.ros.org/en/humble/Tutorials/Intermediate/Launch/Launch-Main.html">here</a>.
			</p>

			<p class="subsection">Changin Parameters at Launch</p>
             -->

			<p class="section">Conclusions and <i>future</i> lectures</p>
			<p>
				This complete everything we needed to see for this lecture.<br>
				We're getting really close to be able to fully control a ROS robot.<br><br>
			

				What is left now is to learn how to write actions (and some other little things, but nothing fancy).<br>
				This will be the main focus of the next lecture. After that, we will be ready to introduce Gazebo
				and finally start having fun with simulated robots!<br><br>

				See you soon!

				

			</p>


			<div class="to_be_continued"></div>


        </div>
    </body>
</html>